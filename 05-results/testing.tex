\section{Test Results}\label{sec:test-results}
Testing Ethereum contracts can be approached in several ways, but the choices
one can make with regards to testing mostly align themselves into one of two
categories: the driver which is executing the contract being tested and the
network environment the contract is being tested within.


\begin{enumerate}
  \item The test driver generally comes in one of two shapes:

    \begin{enumerate}
      \item Contract-to-contract unit tests, which use tests written as smart
        contracts to drive contract execution. These tests provide confidence
        that inter-contract communication will function as expected.

      \item Client-to-contract unit tests, which use transactions generated by
        external accounts to drive contract execution. These tests provide
        confidence that external accounts can run contract code as expected.
    \end{enumerate}

  \item The network environment comes in several shapes, listed from least
    realistic to most:

    \begin{enumerate}
      \item The \codet{testrpc}, now deprecated, is a Node.js-based Ethereum
        client which simulates a full client and network behavior. It is free to
        execute and fast, but lacks the complexities of a real node.

      \item Ganache, which replaces \codet{testrpc} and is functionally
        identical from a testing perspective.

      \item One can run a local instance of Ethereum. This is is free and
        accurately represents an Ethereum node, but lacks real-world network
        complexities.

      \item There are several ``testnets,'' which are test networks designed for
        actual contract deployments. Testnets provide a close-to-reality network
        environment while still providing a free means of acquiring funds for
        testing.

      \item The most accurate environment to test in is the actual Ethereum
        network; this is not free, but offers a perfect real-world environment
        to test contracts in.
    \end{enumerate}
\end{enumerate}

% Testing Ethereum contracts comes in a few flavors: contract-to-contract and
% client-to-contract tests which can occur on various blockchain networks:
% testrpc, local blockchain, testnet, and livenet.
%
% Contract-to-contract unit tests are used to ensure that contract code can be run
% by internal accounts as expected. Client-to-contract unit tests are used to
% ensure that external accounts can run contract code as expected. Developing
% using the \codet{testrpc} simulates a blockchain network, it is free and fast,
% but lacks the complexities of a real node. Running a local blockchain instance
% is free, accurately represents an Ethereum node, but lacks real-world network
% complexities. The testnet is a test network designed for actual Ethereum
% contract deployments, it accurately simulates much of the network infrastructure
% and traffic while still providing free means of acquiring funds for testing. The
% final stage of testing is deploying code onto the actual Ethereum network, this
% is not free but offers a real-world environment to test contract code.
%
% The tests for Norman are client-to-contract tests with contracts deployed using
% the testrpc, on a local blockchain, and on the testnet. Mocha is used as a
% JavaScript testing framework, EmbarkJS is used to provide a JavaScript interface
% to contract code, and Chai is used as an assertion library.

The tests built in this research leverage the \codet{testrpc} and Ganache as
development and testing environments, generally launched as either
\codet{ganache-cli --accounts 100 --networkId 7357} or \codet{testrpc --gasLimit
0xffffffff --port 8546}. Tests were driven through JavaScript and TypeScript
contract bindings using the Embark and Truffle frameworks respectively.

\subsection{Election Components}
Several election contracts were implemented with various modifications to their
implementations based on their underlying electoral system and features being
targeted. Each election contract accepts a configuration object containing the
choices available for the election along with various other properties based on
the requirements of the underlying electoral system. Additional details
regarding implementation are available in Appendix~\ref{appendix:documentation}.


\subsubsection{Election Simulation}

To generate estimates regarding the cost of execution and storage required to
support features of electoral systems, several sets of elections were simulated
using various configurations of contract implementation, choice availability,
ballot structure, and voter selection. The general process required producing
minimal implementations of each electoral system and modifying them as necessary
to explore the advantages and disadvantages of various design choices. Each
electoral system implementation then had minimal tests written to validate that
basic functionality was present, then simulations implemented. Each simulation
leveraged hundreds of accounts which were generated for our test network using
Ganache. Each account, to the extent supported by the underlying electoral
system, made random voting choices: selecting and scoring candidates through
pseudorandom number generation.

\begin{spacing}{1.2}
  % \caption{Gas consumption as measured by contract and simulation.} \\
  \small
  \begin{longtabu} to \textwidth{X[l] X[1,r] X[0.3,c] X[0.4,r] X[0.75,r] X[0.75,r]}
      \caption{Simulated gas consumption by contract function.} \\
      \toprule
      Contract           & \multicolumn{2}{r}{{Operation}} &      & \multicolumn{2}{r}{{Gas Consumption}}   \\
                         \cmidrule(lr){2-3}        \cmidrule(lr){5-6}
                         & Function       & Call & Voters & Total            & Average              \\
      \midrule
      \endhead
      UniCastFptp        & vote           &    1 &    100 &  \num{8007700}   & \num{80077}          \\
      UniCastRangeVote   & vote           &    1 &    100 &  \num{17417564}  & \num{174175}         \\
      MultiCastFptp      & vote           &    1 &    100 &  \num{7447632}   & \num{74476}          \\
      MultiCastFptp      & vote           &    2 &    100 &  \num{3208496}   & \num{32084}          \\
      MultiCastRangeVote & vote           &    1 &    100 &  \num{23266645}  & \num{232666}         \\
      MultiCastRangeVote & vote           &    2 &    100 &  \num{9525039}   & \num{95250}          \\

      UniCastFptp        & tally          &    1 &      1 &  0               & 0                        \\
      UniCastRangeVote   & tally          &    1 &      1 &  \num{149356}    & \num{149356}             \\
      MultiCastFptp      & tally          &    1 &      1 &  \num{917790}    & \num{917790}             \\
      MultiCastRangeVote & tally          &    1 &      1 &  \num{5342859}   & \num{5342859}            \\

      UniCastFptp        & computeResults &    1 &      1 &  \num{360516}    & \num{360516}             \\
      UniCastRangeVote   & computeResults &    1 &      1 &  \num{47416}     & \num{47416}              \\
      MultiCastFptp      & computeResults &    1 &      1 &  \num{47438}     & \num{47438}              \\
      MultiCastRangeVote & computeResults &    1 &      1 &  \num{47394}     & \num{47394}              \\
      \bottomrule\label{tab:election-simulations}
  \end{longtabu}
\end{spacing}
% \footnotetext{
%   These values were generated by taking the average gas consumption observed
%   over several simulation runs. Simulations were configured using 100 voters in
%   each run, with 10 available choices to select from in each election, and a
%   random ballot submission process. The tally and results of each election were
%   validated independently alongside the contract's results.
%   % \begin{enumerate}[leftmargin=5mm,topsep=0mm]
%   %   \item These values are from several simulation runs using 100 voters and a
%   %     random ballot submission process.
%   % \end{enumerate}
% }

% \footnotemark{}
Table~\ref{tab:election-simulations} documents the result of contract
simulations, mapping gas consumption by election contract function. These values
were generated by measuring the total gas consumption observed over several
simulation runs and computing the average cost per contract function.
Simulations were configured using 100 voters in each run, with 10 available
choices to select from in each election. A random choice selection and
evaluation process was used to generate ballots used to  vote. The tally and
results of each election were validated independently alongside the contract's
results.

\paragraph{Ballot Storage and Tallying Algorithms}

Section~\ref{sec:elections} introduced concepts regarding ballot structure and
tallying algorithm. Section~\ref{sec:electoral-criteria} further-refined
these ideas while introducing the ballot counting criteria: polytime,
resolvable, and summability. To measure the significance of these criteria and
the impact of various ballot formats on our overall design, several
implementations of FPTP and range vote were implemented and simulated.

\begin{enumerate}
  \item \sol{UniCastFptp} is an implementation of first-past-the-post which was
    designed to permit a single ballot to be cast per voter. This implementation
    takes advantage of the summability criterion to avoid storing each
    individual voter's ballot and instead maintains a continuous tally of the
    ballots. The space required is therefore constant with respect to the number
    of voters and linear with respect to the number of candidates whose
    \solt{vote_counts} are being tallied.

  \item \sol{UniCastRangeVote}, like \solt{UniCastFptp}, is an implementation
    of range vote designed to only allow a single ballot to be cast per voter.
    This implementation again takes advantage of the summability criterion to
    avoid storing each individual voter's ballot and instead maintains a
    continuous tally of the ballots. The range vote implementation needs to
    store slightly more information to support its tallying algorithm, but
    shares the same storage complexity as the \solt{UniCastFptp} implementation.
\end{enumerate}

% \paragraph{Multi-vote Functionality}
The \sol{UniCastFptp} implementation demonstrated a \emph{very} consistent gas
consumption across its function calls through the exercised simulations.
The \solt{UniCastRangeVote} implementation maintained a slightly less consistent
gas consumption across function calls, but stayed respectably stable.

\subparagraph{Multi-Vote Functionality and Tallying Algorithms}
The functional requirements laid out in Section~\ref{sec:requirements} and
Table~\ref{tab:research-requirements} demand multi-vote support. Two contracts
were written to demonstrate this functionality.

\begin{enumerate}
  \item \sol{MultiCastFptp}, an implementation of first-past-the-post designed
    to permit a voter to cast multiple ballots.

    % This implementation takes advantage of the summability criterion to avoid
    % storing each individual voter's ballot and instead maintains a continuous
    % tally of the ballots. The space required is therefore constant with respect
    % to the number of voters and linear with respect to the number of candidates
    % whose \solt{vote_counts} are being tallied.

  \item \sol{MultiUniCastRangeVote}, like \solt{MultiCastFptp}, is an
    implementation of range vote designed to allow multiple ballots to be cast
    per voter.

    % This implementation again takes advantage of the summability criterion to
    % avoid storing each individual voter's ballot and instead maintains a
    % continuous tally of the ballots. The range vote implementation needs to
    % store slightly more information to support its tallying algorithm, but
    % shares the same storage complexity as the \solt{UniCastFptp}
    % implementation.
\end{enumerate}

It is clear that a voter's ability to cast multiple ballots in an election could
only be considered fair if the principle of ``one person, one vote'' were
adhered to. That is to say, any ballot which has been submitted and had some
partial tally applied based on its marks \emph{must} have its computations
undone before a newer ballot's marks can be considered for tallying. The ability
to cast multiple ballots therefore carries with it an implied requirement of
vote reversal. In order to reverse a previous ballot's impact on a tally,
knowledge of the ballot's marks is required. Therefore, the most recent ballot
of each voter must be maintained in the contract's state to support
vote-reversal in the incident that they cast multiple ballots.

This draws into question the viability and utility of leveraging the summability
criterion as a storage-saving feature, as was leveraged in the previous
contracts, and introduces questions with regard to the \emph{eager evaluation vs
lazy evaluation} of tallying algorithms. The unicast implementation of each
electoral system took advantage of eager evaluation, which essentially forced
each voter to pay a nominal amount of extra gas to keep the current tally of
each choice maintained, this is reflected in
Table~\ref{tab:election-simulations} by the low gas cost associated with the
unicast \solt{tally} functions (0 in the case of \sol{contract UniCastFptp}!).
The more traditional approach to tabulating results in an election is to defer
the tallying procedure until the end of the voting period and have an election
administrator incur the cost and responsibility of tallying ballots. This was
the approach taken in the multicast implementations of these two contracts;
however, it is worth noting that a middle-ground exists which would increase the
cost to vote by a nominal amount and result in a less-expensive tally cost.

One interesting outcome regarding ballot storage and storage costs is reflected
in Table~\ref{tab:election-simulations}; there is a  dramatic reduction in gas
costs incurred when casting a second ballot. The high initial gas cost reflects
the high charge incurred for consuming storage space on the blockchain. The
lower cost reflected by the second call is a product of the new ballot replacing
the old ballot in storage, therefore consuming no additional space on the
blockchain.

\paragraph{Precision Decision and Casting Fake Ballots}
Each electoral system has advantages and disadvantages. It is the responsibility
of those selecting and designing such systems to attempt to balance those
advantages and disadvantages in a reasonable way. Two examples of this
encountered during this research can be seen in the range vote implementations.
The range vote implementation requires the following configuration to be
provided during contract construction:

\begin{solidity}[RangeVoteConfiguration]
struct RangeVoteConfiguration {
  string[] choices;
  RangeVoteConfigurationFakeBallots fake_ballots;
  uint8 min_range;
  uint8 max_range;
  uint8 tally_precision;
}

struct RangeVoteConfigurationFakeBallots {
  uint8 score;
  uint40 voter_count;
}
\end{solidity}

The \sol{tally_precision} value is worth addressing. The tallying algorithm used
to determine the rank of a choice in a range vote election is computed by taking
the summation of all of the scores cast for the choice and dividing that
summation by the number of voters who ranked the choice. This produces a score
average which is used to determine the winner of an election. One weakness of
the EVM is that floating point operations are not supported; in order to address
that a tally precision is used, which multiplies the \solt{score_sum} by
$10^{tally\_precision}$ before dividing it to maintain some degree of precision.
What an appropriate value to assign to \sol{tally_precision} is will depend on
the specifics of the election.

Another value worth addressing is the \solt{struct} \sol{fake_ballots} property.
One weakness of the range vote electoral system is that naive implementations
can result in elections where unknown alternatives, being neither voted for or
against, win elections again more popular alternatives; imagine voting for
oneself in a large election, and being the only person to, therefore winning the
election with a perfect score average. One common technique to avoid this kind
of result in range vote implementations is for election administrators to agree
ahead of time to some number of fake ballots to be cast. These fake ballots will
score each choice with the same rank, typically 0, and therefore bias results
towards choices which have received enough votes to overcome the low scores
received from the fake ballots.

\paragraph{Modeling Finite-State Machine Transitions}
Election contract's state transitions were tested by creating and conducting
mock elections to ensure that the results are as expected. Passage of time in
the \codet{testrpc} is simulated using the \sol{evm_increaseTime} RPC
method.\cite{testrpc}

\begin{itemize}
  \item \textbf{First-Past-the-Post} The tests for the First-Past-the-Post
    electoral system are as follows:
    \begin{enumerate}
      \item Generate a First-Past-the-Post instance.
      \item Test that the owner and creation time are properly initialized.
      \item Confirm that the phase is \sol{Configuration}.
      \item Add two choices to be voted for.
      \item Set the voting start time.
      \item Set the voting end time.
      \item \sol{freeze} the contract so that no further configuration can occur.
      \item Confirm that the contract is \sol{Frozen}.
      \item Increase the time of the EVM such that the contract's
        \sol{timedTransitions} will trigger and move the contract into the
        \sol{Vote} phase on the first ballot submission.
      \item Generate a set of Ethereum accounts and vote for the choices.
      \item Monitor the cast ballots to confirm that the votes are submitted as
        expected.
      \item Confirm that the phase is \sol{Vote}.
      \item Increase the time of the EVM such that the contract's
        \sol{timedTransitions} will trigger and move the contract into the
        \sol{Tally} phase.
      \item Loop over the choices to find the winner.
      \item Confirm that the winner is the expected winner.
      \item Confirm that the phase is \sol{Tally}
    \end{enumerate}

  \item \textbf{Range Vote} The tests for the Range Vote electoral system are as
    follows:
    \begin{enumerate}
      \item Generate a Range Vote instance.
      \item Test that the owner and creation time are properly initialized.
      \item Confirm that the phase is \sol{Configuration}.
      \item Add three choices to be voted for.
      \item Set the voting start time.
      \item Set the voting end time.
      \item \sol{freeze} the contract so that no further configuration can occur.
      \item Confirm that the contract is \sol{Frozen}.
      \item Increase the time of the EVM such that the contract's
        \sol{timedTransitions} will trigger and move the contract into the
        \sol{Vote} phase on the first ballot submission.
      \item Generate a set of Ethereum accounts and vote for the choices.
      \item Monitor the cast ballots to confirm that the votes are submitted as
        expected.
      \item Confirm that the phase is \sol{Vote}.
      \item Increase the time of the EVM such that the contract's
        \sol{timedTransitions} will trigger and move the contract into the
        \sol{Tally} phase.
      \item Loop over the choices to find the winner.
      \item Confirm that the winner is the expected winner.
      \item Confirm that the phase is \sol{Tally}
    \end{enumerate}
\end{itemize}

\subsection{Authorization Components}
There are a number of contracts that need testing that revolve around
authorization, the most important being the \sol{VoterRegistrationAuthority},
\sol{Guard}, \sol{ACLAuthority}, and \sol{BasicACL}.

\paragraph{Voter Registration Authority}
The tests for the \sol{VoterRegistrationAuthority} are as follows:
\begin{enumerate}
  \item Generate a set of external voting accounts.
  \item Deploy an instance of the \sol{VoterRegistrationAuthority}.
  \item Register a subset of the voting accounts with the
    \sol{VoterRegistrationAuthority}.
  \item Verify that the registered voting accounts return true when passed to
    \sol{isRegistered}.
  \item Verify that the unregistered voting accounts return false when passed to
    \sol{isRegistered}.
  \item Unregister a subset of the registered voting accounts.
  \item Verify that the registered voting accounts return true when passed to
    \sol{isRegistered}.
  \item Verify that the unregistered voting accounts return false when passed to
    \sol{isRegistered}.
\end{enumerate}

\paragraph{Guard}
The \sol{Guard} is tested using the previously deployed
\sol{VoterRegistrationAuthority} as an \sol{Authority}. A \sol{TestGuard}
instance is tested by attaching an \sol{auth} modifier to a dummy \sol{vote}
function. The \sol{vote} function is then tested by confirming that each of the
verified voting accounts can call the \sol{vote} function. Each unregistered
account is also tested to confirm that none of those accounts can call the
\sol{vote} function.

% TODO:
% Words:
% Authority
% Secure
% Authorize
% Authenticate
% Security
% SecureContract
% Firewall
% Privilege
% Verify

% \subsection{Election Components}
% Election contracts are tested by creating and conducting mock elections to
% ensure that the results are as expected. Passage of time in the testrpc is
% simulated using the \sol{evm_increaseTime} RPC method.
%
% \subsubsection{First-Past-the-Post}
% The tests for the First-Past-the-Post electoral system are as follows:
% \begin{enumerate}
%   \item Generate a First-Past-the-Post instance.
%   \item Test that the owner and creation time are properly initialized.
%   \item Confirm that the phase is \sol{Configuration}.
%   \item Add two choices to be voted for.
%   \item Set the voting start time.
%   \item Set the voting end time.
%   \item \sol{freeze} the contract so that no further configuration can occur.
%   \item Confirm that the contract is \sol{Frozen}.
%   \item Increase the time of the EVM such that the contract's
%     \sol{timedTransitions} will trigger and move the contract into the
%     \sol{Vote} phase on the first ballot submission.
%   \item Generate a set of Ethereum accounts and vote for the choices.
%   \item Monitor the cast ballots to confirm that the votes are submitted as
%     expected.
%   \item Confirm that the phase is \sol{Vote}.
%   \item Increase the time of the EVM such that the contract's
%     \sol{timedTransitions} will trigger and move the contract into the
%     \sol{Tally} phase.
%   \item Loop over the choices to find the winner.
%   \item Confirm that the winner is the expected winner.
%   \item Confirm that the phase is \sol{Tally}
% \end{enumerate}
%
% \subsubsection{Range Vote}
% The tests for the Range Vote electoral system are as follows:
% \begin{enumerate}
%   \item Generate a Range Vote instance.
%   \item Test that the owner and creation time are properly initialized.
%   \item Confirm that the phase is \sol{Configuration}.
%   \item Add three choices to be voted for.
%   \item Set the voting start time.
%   \item Set the voting end time.
%   \item \sol{freeze} the contract so that no further configuration can occur.
%   \item Confirm that the contract is \sol{Frozen}.
%   \item Increase the time of the EVM such that the contract's
%     \sol{timedTransitions} will trigger and move the contract into the
%     \sol{Vote} phase on the first ballot submission.
%   \item Generate a set of Ethereum accounts and vote for the choices.
%   \item Monitor the cast ballots to confirm that the votes are submitted as
%     expected.
%   \item Confirm that the phase is \sol{Vote}.
%   \item Increase the time of the EVM such that the contract's
%     \sol{timedTransitions} will trigger and move the contract into the
%     \sol{Tally} phase.
%   \item Loop over the choices to find the winner.
%   \item Confirm that the winner is the expected winner.
%   \item Confirm that the phase is \sol{Tally}
% \end{enumerate}

% \subsection{Delegation Components}
% \todo{Finish documenting the delegation contract tests.}

% \section{Authentication Contract}
% The role of the Authentication Contract is to build and maintain a set of
% eligible voter's (whitelist), ineligible voter's (blacklist), and Authentication
% Contract authorities' (publisher's) public keys. Note that this is similar to
% the signing of keys to build a web of trust.
%
% Beyond a whitelist there should also be some sort of technique to
% (???automatically generate???) private keys (BIP-0032 comes to mind).
%
% \emph{TODO:\ Should this be generated using recursive ``signing'' contracts
% (building a Web-of-Trust)? One global signing contract could maintain a
% collection of (public key, signing contract) pairs. Each signing contract could
% only be updated by the private key associated with the public key that created
% the contract and would itself maintain a list of public keys that it considers
% legitimate.}
%
% \emph{TODO:\ Merkle tree to store the state of the contract at a particular
% block? Used to get a static version of valid keys.}
%
% \subsection{Functionality}
%
% \begin{center}
% \resizebox{\columnwidth}{!}{%
%     \begin{tabu} to \textwidth{@{} l l l @{}}
%         \toprule
%         \textbf{Key}    & \textbf{Type}     & \textbf{Description} \\
%         \midrule
%         name            & String            & A name for this authentication contract. \\
%         admins          & Set<Key>          & A collection of authentication contract administration officials' public keys. \\
%         dkg\_key        & Key               & A public key generated by authentication officials using a DKG process. \\
%         seed\_start     & Integer           & The starting key permitted to be generated by the DKG\_Key. \\
%         seed\_end       & Integer           & The ending key permitted to be generated by the DKG\_Key. \\
%         whitelist       & Set<Key>          & A collection of authorized keys. \\
%         blacklist       & Set<Key>          & A collection of unauthorized keys. \\
%         \bottomrule
%     \end{tabu}
% }
% \end{center}
%
% \paragraph{Functionality 1: Creation}
% A collection of authentication administrators create an Authentication Contract:
% register their public keys, perform a DKG process (publish the public key),
% and collectively add/remove users from the whitelist, blacklist, and
% publisher list.
%
% The number of election officials required for each of these operations should be
% variable --- e.g., 2-of-N, 3-of-N;\ where *N* is the total number of election
% officials.
%
% \emph{TODO:\ Is the DKG process necessary in this case? It will probably need to
% be recomputed for every new administrator added/removed and does not seem to
% provide a value add. The DKG public key could be used for the deterministic key
% generation.}
%
% \paragraph{Functionality 2: Whitelist}
% The whitelist offers a means of adding individual public keys. This is useful
% for small authentication contracts and exceptions in the case of seed, but
% should probably be avoided in large-scale contracts.
%
% One nice feature of a whitelist is that the private key is never known to the
% authentication contract administrators.
%
% \paragraph{Functionality 3: Deterministic Keys}
% The deterministic generation of valid keys is an important convenience feature
% for the authentication contract administrators (and optimization feature with
% respect to the blockchain). This feature would allow administrators to
% deterministically generate and whitelist public keys without actually needing to
% write them into the blockchain (similar to BIP-0032). 3rd party contracts could
% validate and verify public keys by performing the same deterministic
% computations as the election officials.
%
% This feature implies that there be additional \lstinline|seed_start| and
% \lstinline|seed_end| values which would limit the range of valid deterministically
% generated public keys. \lstinline|seed_start| and \lstinline|seed_max| could be updated
% by election administrators.
%
% Ultimately this functionality would provide a lost-cost and effective means
% of adding swaths of keys into the whitelist without actually needing to write to
% the blockchain (writing data into the blockchain is an expensive operation
% [?]).
%
% One negative consequence of this technique is that private keys probably need to
% be distributed by authentication contract administrators, perhaps by mail. This
% leaves open some attack vectors; BIP-0032-like functionality might help to track
% down attacks, but couldn't prevent them.
%
% \paragraph{Functionality 4: Blacklist}
% The blacklist offers a means of removing individual public keys from the
% contract, e.g., in the case of lost keys, death, or compromised keys. The
% blacklist should take priority over the whitelist and the deterministically
% generated keys, i.e., \emph{no public key in the blacklist should ever be considered
% valid}.
%
% \paragraph{Functionality 5: Administrator List}
% The authentication contract administrators should be able to add and remove
% members to and from the collection of administrators. This is perhaps the most
% risky operation when compared to the others. Administrators should be heavily
% vetted as the integrity of the authentication contract depends on their
% diligence and maintenance. Thusly, the addition of new members to the
% authentication contract should probably require a supermajority approval from
% other authentication administrators. This approval process should be public in
% order to track down discovered corruption.
%
% \emph{TODO:\ The addition/removal of contract officials implies that the DKG process
% needs to be re-run. This impacts the public/private key deterministic generation
% process. The key generation and administration addition/removal process needs to
% be more carefully considered.}
%
% \section{Proxy Contract}
% The Proxy Contract enables voters to delegate their vote to another voter.
%
% \subsection{Functionality}
%
% \begin{center}
% \resizebox{\columnwidth}{!}{%
%     \begin{tabu} to \textwidth{@{} l l l @{}}
%         \toprule
%         \textbf{Key}        & \textbf{Type}     & \textbf{Description} \\
%         \midrule
%         name                & String            & A name for this proxy (Science, Economics, Social). \\
%         auth\_contract      & Contract          & The authentication contract which contains the set of eligible voters. \\
%         parent\_proxy       & Contract          & The parent proxy contract of this proxy contract (hierarchical proxy capability). \\
%         proxies             & Set<Key>          & A collection of public keys which have agreed to act as proxies. \\
%         election\_contract  & Contract          & An election contract with proxies as options. \\
%         \bottomrule
%     \end{tabu}
% }
% \end{center}
%
% {Note: The \lstinline|auth_contract| and \lstinline|parent_proxy| contract are mutually exclusive.}
%
% {Note: The root \lstinline|parent_proxy| must contain an \lstinline|auth_contract|.}
%
% \paragraph{Functionality 1: Proxy Consent}
% To become an eligible proxy you must first consent to act as a proxy. This is
% done by calling \lstinline|proxy.consent()| with a valid public key from
% \lstinline|auth_contract|.
%
% \emph{TODO:\ Merkle tree to store the state of the contract at a particular block?
% Used to get a static version of valid keys.}
%
% \paragraph{Functionality 2: Create Election}
% Register a new election with all proxies and parent proxies as choices in the
% election. If an election already exists then the election should pre-seed with
% the encrypted votes from the previous proxy election (effectively keeping
% previous delegations).
%
% \section{Election Contract}
% The role of the Election Contract is to build and run elections as well as
% ensure the integrity and security of its elections and participating actors. A
% number of cryptographic and cryptoeconomic incentivization-disincentivization
% schemes are used to maintain election integrity and security.
%
%
% \subsection{Functionality}
%
% \begin{center}
% \resizebox{\columnwidth}{!}{%
%     \begin{tabu} to \textwidth{@{} l l l @{}}
%         \toprule
%         \textbf{Key}        & \textbf{Type}                 & \textbf{Description} \\
%         \midrule
%         administrators      & Set<Key>                      & A set of public keys associated with each of the administration officials of the election. \\
%         DKG\_key            & Key                           & A public key generated by election officials using a DKG process. \\
%         name                & String                        & A name for this election (Minimum Wage, Proxy, New Cafeteria Food). \\
%         description         & String                        & A short description of this election. \\
%         choices             & Set<String>                   & A set of choices. \\
%         start\_time         & Unsigned Integer              & The start time of the election. \\
%         end\_time           & Unsigned Integer              & The end time of the election. \\
%         proxy\_time         & Unsigned Integer              & The time all proxy votes have to be in by. \\
%         write\_in           & Boolean                       & Allow write-in ballots (default: false).\\
%         auth\_contract      & Contract                      & The authentication contract which contains the set of eligible voters. \\
%         proxy\_contract     & Contract                      & The proxy contract that applies to this election. \\
%         mixnet\_nodes       & Set<Key>                      & A set of public keys associated with each of the nodes in the mixnet. \\
%         mixnode\_fee        & Unsigned Integer              & The cost associated with becoming a mixnet node. \\
%         proxy\_ballot       & Map<Key, PlaintextBallot>     & A mapping of authenticated proxy voter's public keys to their plaintext ballots. \\
%         voter\_ballot       & Map<Key, EncryptedBallot>     & A mapping of authenticated voter's public keys to their encrypted ballots. \\
%         \bottomrule
%     \end{tabu}
% }
% \end{center}
%
% \paragraph{Functionality 1: Creation}
% A quorum of election officials form to administer the election contract. The
% quorum of election officials register their public keys, perform a DKG process
% (publish the public key), and collectively configure the election parameters:
% \lstinline|name|, \lstinline|description|, \lstinline|choices|, \lstinline|start_time|, \lstinline|end_time|, \lstinline|proxy_time|,
% \lstinline|proxy_contract|, and \lstinline|auth_contract|.
%
% Election officials must each individually submit good faith deposits (security
% deposits), binders to the election contract which will be forfeited should the
% election decryption stage fail. Their binders collectively should sum to enough
% ether to reimburse each voter in case of election failure. Should decryption
% fail all election official's deposits will be forfeited.
%
% Officials will be rewarded for administering the election process if the
% election proceeds without dishonesty.
%
% \emph{TODO:\ Could we have a bidding process here for the decryption step?}
% \emph{TODO:\ Separate administration from decryption.}
%
% \paragraph{Functionality 2: Mixnet Node Registration}
% Immediately after the creation of the election contract a bidding process
% begins and continues to run until the \lstinline|end_time| of the election. Bidders bid
% in the bidding process to become nodes in the mixnet. The five highest bidders
% are selected as nodes in the mixnet. The starting bid is the cost to run the
% election.
%
% The bids act as good faith deposits, binders to the election contract which will
% be forfeited should the mixnet node be found guilty of dishonesty.
%
% Election officials are collectively guaranteed up to three nodes in the mixnet.
% Each node could of course be a mixnet itself.
%
% 8 nodes total? Configurable?
%
% The election officials use a
%
% \emph{TODO:\ Is an exponential bidding process viable?}
%
% \emph{TODO:\ We should probably just use the 5 highest bidders. We'll just fall victim
% to a Sybil attack if we try to do some partitioning of bidders to allow cheaper
% bidders into the game and randomly select from them. It's functionally identical
% to the highest bidder winning.}
%
% \emph{TODO:\ 5 and 5 was a completely arbitrary choice. This probably isn't necessary
% for a low stakes election. This should probably be determined based on number of
% voters and election administrator configuration.}
%
% \paragraph{Functionality 3: Submit Ballot --- Proxy}
% Proxy voters, proxies, can submit plaintext votes using an account
% associated with their authorized public key.
%
% After the \lstinline|proxy_time| has passed proxies can no longer vote using their proxy
% ballot. If they have not committed to a proxy ballot before the \lstinline|proxy_time|
% then they are eligible to vote using a voter ballot.
%
% *Note: Proxies can only vote with the votes that have been delegated to them, not
% their own vote; e.g., Bob and Charlie both delegate their vote to Alice, Alice
% can now vote with a weight of 2 (Bob and Charlie's vote), not 3 (she's lost her
% own vote). Further, only proxies can submit votes using proxy ballots. Both of
% these properties exist to maintain receipt freedom freedom.
%
% Another way to imagine this is as a tree of voters, where the leaves of the tree
% give weight to the vote and the non-leaf nodes influence the direction/choice of
% the vote.*
%
% *Note: We need to have a static version of the proxy so that voters cannot
% remove their proxy vote and vote again; and so that proxies cannot vote, then
% remove their proxy status, then vote again.*
%
% \paragraph{Functionality 4: Submit Ballot --- Voter}
% If a voter has not submitted a proxy ballot then a voter may submit a ballot
% encrypted using the DKG public key produced by the election administrators.
% Ballots are encrypted using an El Gamal encryption scheme which provides
% re-encryption and additive homomorphic features.
%
% \paragraph{Functionality 5: Verification}
% For a week after the election, verifiers, for a charge, can challenge the mixnet
% nodes. If a mixnet node does not respond in a timely fashion to each of the
% challenges then the mixnet node is accused of dishonesty and their binder is
% forfeit. The dishonest mixnet node is booted from the mixnet and the mixnet is
% rerun. 40\% of the dishonest node's good faith deposit is given given to the
% verifier of the election as a reward for discovering the dishonesty. 30\% of the
% dishonest node's deposit is burned, and the last 30\% of the deposit is put into
% the reward pool for the election which is split between election administrators
% and honest mixnet nodes.
%
% \emph{TODO:\ Should voters be given some of the reward?}
%
% The verification functionality is broken into two parts: commitment,
% verification, and collection.
%
% \subparagraph{Commmit}
% The verifier commits to challenging a mixnet node by submitting a transaction
% containing a hash of verification challenge parameters, the node that they wish
% to challenge, a reward address, and a deposit (enough gas/ether to verify the
% transaction on chain). An immutable mapping is created that links the hash of
% the verification parameters to the reward address.
%
% \subparagraph{Verify}
% After the verifier is sufficiently convinced that their hash is set in the
% blockchain they can activate the verification process by revealing their
% challenge parameters, a portion of the mix node proof, and the necessary merkle
% tree elements to confirm the legitimacy. The verification parameters are
% computed against the mixnet node's published proof to detect dishonesty. The
% previously mentioned mixnet node punishment occurs if dishonesty is discovered.
%
% *Note: If they verifier never reveals their verification parameters then their
% deposit is forfeit and added to the contract reward pool.*
%
% \paragraph{Final Notes}
% Receipt freedom might be compromised if an organization large enough proxies
% their votes individually to people they wish to coerce or vote buy from.
%
% Mixnode attack to delay election.
%
% Verifier attack to refund money in mixnode delay attack.
%
% \section{Stages}
% As seen above the Election Contract depends on the Authentication Contract
% and/or Proxy Contract, however it is useful to understand the voting system
% beginning with the Election.
%
% \begin{figure}[H]
%     \centering
%     \caption{Stages of election.}\label{fig:blockchain}
%     \includestandalone[width=\textwidth]{\fig{stages}}
% \end{figure}
%
% \begin{enumerate}
%     \item Creation
%         \begin{enumerate}[a.]
%             \item Election administrators perform a distributed key generation
%                 process to generate an ElGamal key pair that supports additive
%                 homomorphic properties.
%             \item The public key is published to the election contract.
%         \end{enumerate}
%     \item Configuration
%         \begin{enumerate}[a.]
%             \item Election administrators add additional election administrators
%                 to the contract.
%             \item Election administrators set the authentication contract.
%             \item Election administrators set the proxy contract.
%             \item Election administrators configure the start time of the
%                 election contract.
%             \item Election administrators configure the end time of the election
%                 contract.
%             \item Election administrators configure the end time for delegate
%                 voting.
%             \item Election administrators configure the number of mixnet nodes
%                 they will operate.
%             \item Election administrators configure the number of mixnet nodes
%                 that will be available for bidders to bid for.
%             \item Election administrators freeze the configuration process. No
%                 additional configurations are accepted by the contract after
%                 this point. This signals the bidding process for external mixnet
%                 participants.
%         \end{enumerate}
%     \item Voting Begins
%         \begin{enumerate}[a.]
%             \item Voting begins at the start time specified by election
%                 administrators.
%             \item Delegates must publish their ballots unencrypted to leverage
%                 votes that have been delegated to them. Note that delegates
%                 forfeit their own vote to leverage their constituent's votes.
%         \end{enumerate}
%     \item Proxy Voting Ends
%         \begin{enumerate}[a.]
%             \item Proxy voting has ended. Voters now have an opportunity to
%                 override their proxy's public vote by publishing an encrypted
%                 ballot. Note that delegates who have published an unencrypted
%                 ballot have locked themselves in, they can no longer vote as a
%                 normal voter.
%         \end{enumerate}
%     \item Voting Ends
%         \begin{enumerate}[a.]
%             \item Proxy voting has ended. Voters now have an opportunity to
%                 override their proxy's public vote.
%         \end{enumerate}
%     \item Mixnet Cycle
%         \begin{enumerate}[a.]
%             \item The top n bidders, where n is the number of external mixnet
%                 nodes available for bid, with the highest bids are selected as
%                 the external nodes to participate in the mixnet process. (Should
%                 a blinding process happen? e.g., Ethereum Name Service bidding)
%             \item A node ordering is determined from the set of available nodes
%                 to perform a mix. The nodes are picked using a pseudo random
%                 selection process based off of the hash of the most recent block
%                 (should we use a block from a few back in case another chain is
%                 used?).
%         \end{enumerate}
%     \item Publish Mixnet Proof
%         \begin{enumerate}[a.]
%             \item Each mixnet node publishes their mixed ballots and a proof of
%                 mix. If a node does not publish their required outputs in the
%                 required amount of time they are removed from the mixnet and the
%                 next mixnet node takes their place.
%         \end{enumerate}
%     \item Verification Begins
%         \begin{enumerate}[a.]
%             \item Proof of subproduct
%             \item Any individual or organization willing to verify the proofs
%                 may do so by publishing a challenge and paying an appropriate
%                 fee. If mixnet nodes don't respond within a reasonable time
%                 frame they are removed from the mixnet and the mixnet cycle
%                 restarts.
%         \end{enumerate}
%     \item Tally Results
%         \begin{enumerate}[a.]
%             \item Encrypted votes are tallied together using the additive
%                 homomorphic property.
%         \end{enumerate}
%     \item Decryption Cycle
%         \begin{enumerate}[a.]
%             \item Election administrators come together to generate the private
%                 key and decrypt the tallied votes.
%         \end{enumerate}
%     \item Publish Decryption Proof
%         \begin{enumerate}[a.]
%             \item Election administrators publish their proof of decryption. If
%                 this is not published in the required amount of time the
%                 election fails.
%         \end{enumerate}
%     \item Verification Ends
%         \begin{enumerate}[a.]
%             \item After some period of time passes to allow verifiers to
%                 challenge the decryption proof and mixnet proofs the election
%                 ends.
%         \end{enumerate}
% \end{enumerate}
%
% Notes:
% \begin{itemize}
%     \item Bidders must publish a public key as part of the bidding process.
%     \item Mixnet nodes must remain available for challenges during the entire
%         verification period.
% \end{itemize}
%
%
% \section{Ballot Format}
